# 莱文斯坦距离

## 简介

莱文斯坦距离是俄罗斯科学家莱文斯坦在1965年提出的一种编辑距离，指讲一个字符串转换为另一个所需的最少编辑操作次数

> 编辑距离是对两个字符串的差异程度的度量，通过将一个字符串转换为另一个字符串需要的操作次数来度量，这里的操作由编辑距离自行定义

## 定义

莱文斯坦距离中定义的编辑操作有三种

+ 替换：将某个字符转换为另一个字符，如abc -> abd
+ 添加：在字符串某个位置中添加某个字符，如abc -> abdc
+ 删除：删除字符串中某个字符，如abc -> ab

对于字符串a，b来说，a和b莱文斯坦距离就是把a转换为b(b转换为a是一样的)所需要的最少的编辑操作的数量

主要采用动态规划的算法进行计算，动态规划的介绍可以参考：

+ https://zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92
+ https://oi-wiki.org/dp/basic/

## 计算

接下来介绍具体的计算方式

用 |a| 和 |b| 表示a，b两个字符串的长度，用$lev_{a,b}(|a|, |b|)$表示a和b的莱文斯坦距离，用$lev_{a,b}(i, j)$表示a的前i个字符对应的子字符串和b的前j个字符对应的子字符串的莱文斯坦距离。

假设a = "abc"，b = "edf"，$lev_{a,b}(1,1)$即字符串"a"和字符串"e"之间的莱文斯坦距离

这里需要注意i和j可以为0

+ i 和 j 都为0时，两个空字符串的莱文斯坦距离为0
+ i 和 j其中一个为0时，一个空字符串和另一个非空字符串的莱文斯坦距离为非空字符串的长度（操作就是将非空字符串里的所有字符删除）

当 i 和 j 都不为0时

$lev_{a,b}(i, j) = min(lev_{a,b}(i, j-1) + 1, lev_{a,b}(i-1, j) + 1, lev_{a,b}(i - 1, j - 1) + l_{a_i \neq b_j})$

$lev_{a, b}(i, j)$等于以下四项（其实是三项）中的最小值（因为要最少的操作数）

+ 如果将 a 的第 i 个字符删除，对应的编辑距离就是 a 的前 i-1 个字符对应的子字符串和b的前 j 个字符对应的子字符串的莱文斯坦距离 + 1，即$lev_{a,b}(i-1, j) + 1$
+ 如果将 b 的第 j 个字符删除，对应的编辑距离就是 a 的前 i 个字符对应的子字符串和b的前 j-1 个字符对应的子字符串的莱文斯坦距离 + 1，即$lev_{a,b}(i, j-1) + 1$
+ 如果a 的第 i 个字符和 b 的第 j 个字符相同，对应的编辑距离是 a 的前 i-1 个字符对应的子字符串和b的前 j-1 个字符对应的子字符串的莱文斯坦距离，即$lev_{a,b}(i-1, j-1)$
+ 如果a 的第 i 个字符和 b 的第 j 个字符不同，对应的编辑距离是 a 的前 i-1 个字符对应的子字符串和b的前 j-1 个字符对应的子字符串的莱文斯坦距离 + 1，即$lev_{a,b}(i-1, j-1) + 1$
+ $l_{a_i \neq b_j}$在a 的第 i 个字符和 b 的第 j 个字符不同时为1，否则为0

因此可得以下表达式

$$
lev_{a,b}(i,j) =
\begin{cases}
max(i,j) \quad min(i, j) = 0, \\
min \begin{cases}
lev_{a,b}(i-1,j) + 1 \\
lev_{a,b}(i,j-1) + 1 \\
lev_{a,b}(i-1,j-1) + l_{a_i \neq b_j} \\
\end{cases}
\end{cases}
$$

## 代码实现

本次代码实现了[python版本](leven.py)和[c++版本](leven.cpp)